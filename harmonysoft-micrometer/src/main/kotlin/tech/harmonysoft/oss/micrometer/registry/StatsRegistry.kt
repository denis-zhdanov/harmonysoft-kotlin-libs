package tech.harmonysoft.oss.micrometer.registry

import io.micrometer.core.instrument.Meter
import io.micrometer.core.instrument.MeterRegistry
import io.micrometer.core.instrument.Tag
import tech.harmonysoft.oss.common.execution.ExecutionContextManager
import tech.harmonysoft.oss.micrometer.util.StatsValue
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicReference

/**
 * Facilitates standard Micrometer [Meter] usage when we need to use them with parameters.
 * For example, there might be common 'processingTime' timer and we want to use it for `action=action1`,
 * `action=action2`, etc.
 *
 * Also it has a feature that context data for the target tag names is automatically retrieved from
 * [ExecutionContextManager] and attached to data points generated by this registry's meters.
 *
 * **Note:** we introduce multiple overloaded [getMeter] methods here (`getMeter(tag)`, `getMeter(tag1, tag2)`, etc)
 * instead of providing generic varargs-based processing because stats collection is expected to be performed
 * quite often. Hence, we want to avoid new array construction every time [getMeter] is called.
 *
 * @param tagNames                  list of the tag names to use for the target meter. Note that the order is
 *                                  important - it must be the same as the order of values in the correspondnig
 *                                  [getMeter] call
 * @param staticTags                tags to be applied to every data point collected by this registry's meter
 * @param registry                  meter registry to use
 * @param executionContextManager   context values holder
 * @param contextTagNames           context tag names, their values are picked from [ExecutionContextManager.getFromCurrentContext]
 *                                  and are attached to data points produced by this registry's meters
 * @param meterCreator          meter's initializer
 */
class StatsRegistry<T : Meter>(
    private val tagNames: List<String>,
    private val staticTags: Set<Tag>,
    private val registry: MeterRegistry,
    private val executionContextManager: ExecutionContextManager,

    contextTagNames: Set<String>,
    meterCreator: (MeterRegistry, Iterable<Tag>) -> T
) {

    // we use array here in order to avoid creating Iterator objects during iteration (that might happen often)
    private val _contextTagNames = contextTagNames.toTypedArray()

    private val cacheEntryCreator: (Iterable<Tag>) -> T = {
        meterCreator(registry, it)
    }

    private val cache = CacheEntry(staticTags.toList()) {
        cacheEntryCreator(staticTags)
    }

    fun getMeter(vararg tagValues: String): T {
        if (tagNames.size != tagValues.size) {
            throw IllegalArgumentException(
                "expected to get ${tagNames.size} tag value(s) for tag name(s) $tagNames but got ${tagValues.size}: "
                        + "$tagValues"
            )
        }

        var entry = _contextTagNames.fold(cache) { cacheEntry, tagName ->
            val tagIndex = tagNames.indexOf(tagName)
            val value = if (tagIndex != -1) {
                tagValues[tagIndex]
            } else {
                executionContextManager.getFromCurrentContext<Any>(tagName) ?: StatsValue.NO_VALUE
            }
            cacheEntry.getFor(tagName, value, cacheEntryCreator)
        }
        for (i in tagNames.indices) {
            entry = entry.getFor(tagNames[i], tagValues[i], cacheEntryCreator)
        }

        return entry.meter
    }

    private class CacheEntry<T : Meter>(
        private val tags: List<Tag>,
        private val meterCreator: () -> T
    ) {
        private val meterRef = AtomicReference<T>()
        private val tagNames = tags.map { it.key }.toSet()
        private val childrenByValue = ConcurrentHashMap<Any, CacheEntry<T>>()

        // we use lazy initialization here because an instance with empty custom tags is always created by
        // micrometer infrastructure and StatsRegistry is created. That leads to an empty tag value which
        // litters the stats
        val meter: T
            get() {
                return meterRef.get() ?: run {
                    meterRef.compareAndSet(null, meterCreator())
                    meterRef.get()
                }
            }

        fun getFor(tagName: String, tagValue: Any, meterCreator: (Iterable<Tag>) -> T): CacheEntry<T> {
            return if (tagNames.contains(tagName)) {
                this
            } else {
                childrenByValue[tagValue] ?: childrenByValue.computeIfAbsent(tagValue) {
                    val childTags = tags + Tag.of(tagName, tagValue.toString())
                    CacheEntry(childTags) { meterCreator(childTags) }
                }
            }
        }
    }
}